#!/usr/bin/python

import sys,getopt,os,io,re, json

"""
parse query result log generated by files such as qa.sh
outputs a csv file, order is below in variable "header", which it prints as first csv line.
sample valid log lines:
run-query --num-objs 10000 --pool tpc --wthreads 10 --qdepth 192 --quiet --extended-price 91400.0 --query a --use-cls selectivity-pct=1 cache=hot start=1493088002.115970619 end=1493088006.015125206 run-6 03.899154587
run-query --num-objs 10000 --pool tpc --wthreads 10 --qdepth 192 --quiet --extended-price 91400.0 --query a selectivity-pct=1 cache=hot start=1493087570.394655435 end=1493087736.134972615 run-6 0165.740317180
select count(*) from lineitem where l_extendedprice > 91400
draining ios: 192 remaining
draining ios: 138 remaining
"""

epoch = 0

def makeDict(line, debug):
    tmp = line.split()
    dict = {}
    lineitems = [x.strip("--") for x in tmp[1:len(tmp)-1]]
    if debug: print "lineitems", lineitems
    if "num-objs" in lineitems:
        dict["nobjs"] = lineitems[lineitems.index("num-objs")+1]
    if "wthreads" in lineitems:
        dict["wthreads"] = lineitems[lineitems.index("wthreads")+1]
    if "qdepth" in lineitems:
        dict["qdepth"] = lineitems[lineitems.index("qdepth")+1]
    if "query" in lineitems:
        dict["query"] = lineitems[lineitems.index("query")+1]
    if "pool" in lineitems:
        dict["pool"] = lineitems[lineitems.index("pool")+1]
    if "dir" in lineitems:
        dict["dir"] = lineitems[lineitems.index("dir")+1]
    
    if "use-cls" in lineitems:
        dict["cls"] = "use-cls"
    else:
        dict["cls"] = "no-cls"
    
    for i in lineitems:
        s = i.split("=")
        k = s[0]
        if len(s) == 2: 
            if k in ["start", "end"]:
                v = str(int(float(s[1])))
            else: 
                v = s[1]
        else: v = "" 
         
        if k.startswith("run"):
            v = k.split('-')[1]
            k = "run"
        if k not in dict:  
            dict[k] = v 

    if "resp-time" not in dict:
        dict["resp-time"] = str(int((float(dict["end"]) - float(dict["start"]))))
    if debug: print "dict", dict
    
    global epoch
    if epoch == 0:
        epoch = int(dict["start"]) 
    dict["offset-from-epoch-qstart"] = str(int(dict["start"]) - epoch)
    dict["offset-from-epoch-qend"] = str(int(dict["end"]) - epoch)
    return dict
        
def usage():
    print "usage: --dstatlog <file> --runlog <file> --outfile <outlog> --query <a|b|c|d|e|f|g> --cls <use-cls|no-cls> --cache <cold|hot> --selectivity-pct <1|10|100|unique|none> [--debug]"
    sys.exit(2)
    
    
def main(argv):
    

    try:
        opts, args = getopt.getopt(
            argv,
            "gd:r:o:q:u:c:s:",
            ["debug","dstatlog=","runlog=","outfile=","query=","cls=","cache=","selectivity-pct="])            
    except getopt.GetoptError:
        usage()
        
    global epoch_start 
    epoch_start = 0
    
    debug = False
    dstatlog = ""
    runlog = ""
    outfile = ""
    params = {
        "cls":"",
        "cache":"",
        "query":"",
        "selectivity-pct":""
    }
    
    for opt, arg in opts:
        if opt in ("-g", "--debug"):
            debug = True
        elif opt in ("-d", "--dstatlog"):
            dstatlog = arg        
        elif opt in ("-r", "--runlog"):
            runlog = arg
        elif opt in ("-o", "--outfile"):
            outfile = arg        
        elif opt in ("-q", "--query"):
            params["query"] = arg             
        elif opt in ("-u", "--cls"):
            params["cls"] = arg        
        elif opt in ("-c", "--cache"):
            params["cache"] = arg        
        elif opt in ("-s", "--selectivity-pct"):
            params["selectivity-pct"] = arg   
    
    print "will search for params:"
    print(json.dumps(params, indent=4))
    if runlog == "" or  dstatlog == "" or outfile == "":
        usage()
    
    print "\n\n"
    
    header = ["filename", "nosds", "nobjs","query", "selectivity-pct", "cls", "cache", "start", "end", "resp-time", "offset-from-epoch-qstart", "offset-from-epoch-qend"]
    print ",".join(header)
    
    # this gets the runlog data, we need the start and end time for each query and its params.
    match = False
    start = 0;
    end = 0;
    with open(runlog) as f:
        for line in f:
            if line.startswith("run-query"):
                if debug: 
                    print "line=%s" % line.strip()                
                results = makeDict(line, debug)
                results["filename"] = f.name
                m = re.search(r"(\d+)osd.+", f.name)
                if m: 
                    results["nosds"] = m.group(1)
                else: 
                    results["nosds"] = f.name.rstrip("osds.log")
                data = ",".join(results[k] for k in header)
                #print data
                match = True
                for k,v in params.items():
                    if results[k] == v:
                        match = match and True
                        #print "k=" + k + ";v=" + v
                    else:
                        match = match and False
                if match:
                    start = int(results["start"]) 
                    end = int(results["end"]) 
                    print "found matching runlog line:" + data
                    print "start time=" + str(start) + "; end time=" + str(end) + "; resp time=" + str(end - start)
                    break
                    
    if not match:
        print "no matching runlog line found in input file for given params:" 
        print(json.dumps(params, indent = 4))
        return

    linenum = 0
    matched_lines = 0
    first_line = 0;
    ofile = open(outfile, "w")
    ofile_header = ""
    with open(dstatlog) as f:
        for line in f:
            linenum += 1
            line = line.strip()
            if line.startswith("\"") or len(line)==0 or line.isspace():
                ofile_header += line + "\n"
                continue
            data = line.split(",")
            epoch = float(data[len(data)-2])  # assumes epoch is the last csv value on the dstat logline.
            if (epoch >= start-5) and (epoch <= end+5):
                if matched_lines == 0:
                    ofile.write(ofile_header)
                    first_line = linenum
                matched_lines += 1
                print line
                ofile.write(line+"\n")
      
    print "\n\nstarting with line#:" + str(first_line) + " in dstatlog: " + dstatlog 
    print  "sfound " + str(matched_lines) + " lines that matched where epoch start was " + str(start) + "; epoch end was " + str(end)
    print "extracted from runlog:" + runlog
    print "with query params:"
    print(json.dumps(params, indent = 4))
    

if __name__ == "__main__":
    main(sys.argv[1:])