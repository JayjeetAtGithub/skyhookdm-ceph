#!/usr/bin/python

import sys,getopt,os,io,re, json

"""
parse query result log generated by files such as qa.sh
outputs a csv file, order is below in variable "header", which it prints as first csv line.
sample valid log lines:
run-query --num-objs 10000 --pool tpc --wthreads 10 --qdepth 192 --quiet --extended-price 91400.0 --query a --use-cls selectivity-pct=1 cache=hot start=1493088002.115970619 end=1493088006.015125206 run-6 03.899154587
run-query --num-objs 10000 --pool tpc --wthreads 10 --qdepth 192 --quiet --extended-price 91400.0 --query a selectivity-pct=1 cache=hot start=1493087570.394655435 end=1493087736.134972615 run-6 0165.740317180
select count(*) from lineitem where l_extendedprice > 91400
draining ios: 192 remaining
draining ios: 138 remaining
"""

epoch = 0

def makeDict(line, debug):
    tmp = line.split()
    dict = {}
    lineitems = [x.strip("--") for x in tmp[1:len(tmp)-1]]
    if debug: print "lineitems", lineitems
    if "num-objs" in lineitems:
        dict["nobjs"] = lineitems[lineitems.index("num-objs")+1]
    if "wthreads" in lineitems:
        dict["wthreads"] = lineitems[lineitems.index("wthreads")+1]
    if "qdepth" in lineitems:
        dict["qdepth"] = lineitems[lineitems.index("qdepth")+1]
    if "query" in lineitems:
        dict["query"] = lineitems[lineitems.index("query")+1]
    if "pool" in lineitems:
        dict["pool"] = lineitems[lineitems.index("pool")+1]
    if "dir" in lineitems:
        dict["dir"] = lineitems[lineitems.index("dir")+1]
    
    if "use-cls" in lineitems:
        dict["cls"] = "use-cls"
    else:
        dict["cls"] = "no-cls"
    
    for i in lineitems:
        s = i.split("=")
        k = s[0]
        if len(s) == 2: 
            if k in ["start", "end"]:
                v = str(int(float(s[1])))
            else: 
                v = s[1]
        else: v = "" 
         
        if k.startswith("run"):
            v = k.split('-')[1]
            k = "run"
        if k not in dict:  
            dict[k] = v 

    if "resp-time" not in dict:
        dict["resp-time"] = str(int((float(dict["end"]) - float(dict["start"]))))
    if debug: print "dict", dict
    
    global epoch
    if epoch == 0:
        epoch = int(dict["start"]) 
    dict["offset-from-epoch-qstart"] = str(int(dict["start"]) - epoch)
    dict["offset-from-epoch-qend"] = str(int(dict["end"]) - epoch)
    return dict
        
def usage():
    print "usage: --dstatlog <file> --runlog <file> --query <a|b|c|d|e|f|g> --cls <use-cls|no-cls> --cache <cold|hot> --selectivity-pct <1|10|100|unique|none> [--debug] [--help]"
    sys.exit(2)

def helpmsg():
    print "extracts relevant epoch time portion of large dstat log to match the start to end epoch time of the given query params, which are first extracted from the query run log."
    print "requires as input a dstat csv log (assumes epoch is always the last column), a runlog such as 1osds.log, an output file for the extracted relevant portion of full dstat log, "
    print "and set of query params: query name (a,b...); cls, cache, selectivity-pct as follows."
    usage()
    
    
def main(argv):
    
    try:
        opts, args = getopt.getopt(
            argv,
            "hgd:r:o:q:u:c:s:p:",
            ["help","debug","dstatlog=","runlog=","query=","cls=","cache=","selectivity-pct=","outdir="])            
    except getopt.GetoptError:
        usage()
        
    global epoch_start 
    epoch_start = 0
    
    help = False
    debug = False
    dstatlog = ""
    runlog = ""
    outdir = "./"
    params = {
        "cls":"",
        "cache":"",
        "query":"",
        "selectivity-pct":""
    }
    
    for opt, arg in opts:
        if opt in ("-h", "--help"):
            help = True
        elif opt in ("-g", "--debug"):
            debug = True
        elif opt in ("-d", "--dstatlog"):
            dstatlog = arg        
        elif opt in ("-r", "--runlog"):
            runlog = arg
        elif opt in ("-q", "--query"):
            params["query"] = arg      
        elif opt in ("-p", "--outdir"):
            outdir = os.path.abspath(arg) 
            print "outdir=" + outdir
            if os.path.exists(outdir):   
                print outdir
            else:
                print "ERROR: --outdir does not exist"
                usage()
        elif opt in ("-u", "--cls"):
            params["cls"] = arg        
        elif opt in ("-c", "--cache"):
            params["cache"] = arg        
        elif opt in ("-s", "--selectivity-pct"):
            params["selectivity-pct"] = arg
    
    #print ",".join([str(len(v)) for v in params.values()])
    #if 0 in [len(v) for v in params.values()]:
       # print "\n\n\nhello"
    if help == True:
        helpmsg()
    if runlog == "" or  dstatlog == "" or 0 in [len(v) for v in params.values()]:
        usage()
    print "\n"
    
    header = ["filename", "nosds", "nobjs","query", "selectivity-pct", "cls", "cache", "start", "end", "resp-time", "offset-from-epoch-qstart", "offset-from-epoch-qend"]
    if debug:
        print ",".join(header)
    
    # this gets the runlog data, we need the start and end time for each query and its params.
    match = False
    start = 0;
    end = 0;
    with open(runlog) as f:
        for line in f:
            if line.startswith("run-query"):
                if debug: 
                    print "line=%s" % line.strip()                
                results = makeDict(line, debug)
                results["filename"] = f.name
                m = re.search(r"(\d+)osd.+", f.name)
                if m: 
                    results["nosds"] = m.group(1)
                else: 
                    results["nosds"] = f.name.rstrip("osds.log")
                data = ",".join(results[k] for k in header)
                if debug:
                    print data
                match = True
                for k,v in params.items():
                    if results[k] == v:
                        match = match and True
                    else:
                        match = match and False
                if match:
                    start = int(results["start"]) 
                    end = int(results["end"]) 
                    if debug:
                        print "found matching runlog line:" + data
                        print "start time=" + str(start) + "; end time=" + str(end) + "; resp time=" + str(end - start)
                    break
                    
    if not match:
        print "no matching runlog line found in input file for given params:" 
        print(json.dumps(params, indent = 4))
        return

    linenum = 0
    matched_lines = 0
    first_line = 0;
    fname = dstatlog + \
        ".query." + params["query"] + \
        ".cache." + params["cache"] + \
        ".cls." + params["cls"] + \
        ".sel." + params["selectivity-pct"]
    outpath = os.path.join(outdir, fname)
    print outpath
    ofile = open(outpath, "w")
    ofile_header = ""
    with open(dstatlog) as f:
        for line in f:
            linenum += 1
            line = line.strip()
            if line.startswith("\"") or len(line)==0 or line.isspace():
                ofile_header += line + "\n"
                continue
            data = line.split(",")
            epoch = float(data[len(data)-2])  # assumes epoch is the last csv value on the dstat logline.
            if (epoch >= start-5) and (epoch <= end+5):
                if matched_lines == 0:
                    ofile.write(ofile_header)
                    first_line = linenum
                matched_lines += 1
                if debug:
                    print line
                ofile.write(line+"\n")
    ofile.close()
      
    print "starting with line#:" + str(first_line) + " in dstatlog: " + dstatlog + ","
    print  "found " + str(matched_lines) + " lines that matched with epoch start=" + str(start) + "; epoch end= " + str(end)
    print "in runlog:" + runlog + " with query params:"
    print(json.dumps(params, indent = 4))
    print "output written to\n" + outpath
    

if __name__ == "__main__":
    main(sys.argv[1:])