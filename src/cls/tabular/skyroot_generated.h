// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SKYROOT_TABLES_H_
#define FLATBUFFERS_GENERATED_SKYROOT_TABLES_H_

#include "flatbuffers/flatbuffers.h"

namespace Tables {

struct Root;

struct Rows;

struct Record;

struct Col;

struct IntData;

struct FloatData;

struct StringData;

struct ColInt;

struct ColFloat;

struct ColString;

enum Relation {
  Relation_NONE = 0,
  Relation_Rows = 1,
  Relation_Col = 2,
  Relation_ColInt = 3,
  Relation_ColFloat = 4,
  Relation_ColString = 5,
  Relation_MIN = Relation_NONE,
  Relation_MAX = Relation_ColString
};

inline const Relation (&EnumValuesRelation())[6] {
  static const Relation values[] = {
    Relation_NONE,
    Relation_Rows,
    Relation_Col,
    Relation_ColInt,
    Relation_ColFloat,
    Relation_ColString
  };
  return values;
}

inline const char * const *EnumNamesRelation() {
  static const char * const names[] = {
    "NONE",
    "Rows",
    "Col",
    "ColInt",
    "ColFloat",
    "ColString",
    nullptr
  };
  return names;
}

inline const char *EnumNameRelation(Relation e) {
  if (e < Relation_NONE || e > Relation_ColString) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesRelation()[index];
}

template<typename T> struct RelationTraits {
  static const Relation enum_value = Relation_NONE;
};

template<> struct RelationTraits<Rows> {
  static const Relation enum_value = Relation_Rows;
};

template<> struct RelationTraits<Col> {
  static const Relation enum_value = Relation_Col;
};

template<> struct RelationTraits<ColInt> {
  static const Relation enum_value = Relation_ColInt;
};

template<> struct RelationTraits<ColFloat> {
  static const Relation enum_value = Relation_ColFloat;
};

template<> struct RelationTraits<ColString> {
  static const Relation enum_value = Relation_ColString;
};

bool VerifyRelation(flatbuffers::Verifier &verifier, const void *obj, Relation type);
bool VerifyRelationVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Data {
  Data_NONE = 0,
  Data_IntData = 1,
  Data_FloatData = 2,
  Data_StringData = 3,
  Data_MIN = Data_NONE,
  Data_MAX = Data_StringData
};

inline const Data (&EnumValuesData())[4] {
  static const Data values[] = {
    Data_NONE,
    Data_IntData,
    Data_FloatData,
    Data_StringData
  };
  return values;
}

inline const char * const *EnumNamesData() {
  static const char * const names[] = {
    "NONE",
    "IntData",
    "FloatData",
    "StringData",
    nullptr
  };
  return names;
}

inline const char *EnumNameData(Data e) {
  if (e < Data_NONE || e > Data_StringData) return "";
  const size_t index = static_cast<int>(e);
  return EnumNamesData()[index];
}

template<typename T> struct DataTraits {
  static const Data enum_value = Data_NONE;
};

template<> struct DataTraits<IntData> {
  static const Data enum_value = Data_IntData;
};

template<> struct DataTraits<FloatData> {
  static const Data enum_value = Data_FloatData;
};

template<> struct DataTraits<StringData> {
  static const Data enum_value = Data_StringData;
};

bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type);
bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Root FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCHEMA = 4,
    VT_RELATIONDATA_TYPE = 6,
    VT_RELATIONDATA = 8
  };
  const flatbuffers::Vector<uint8_t> *schema() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SCHEMA);
  }
  Relation relationData_type() const {
    return static_cast<Relation>(GetField<uint8_t>(VT_RELATIONDATA_TYPE, 0));
  }
  const void *relationData() const {
    return GetPointer<const void *>(VT_RELATIONDATA);
  }
  template<typename T> const T *relationData_as() const;
  const Rows *relationData_as_Rows() const {
    return relationData_type() == Relation_Rows ? static_cast<const Rows *>(relationData()) : nullptr;
  }
  const Col *relationData_as_Col() const {
    return relationData_type() == Relation_Col ? static_cast<const Col *>(relationData()) : nullptr;
  }
  const ColInt *relationData_as_ColInt() const {
    return relationData_type() == Relation_ColInt ? static_cast<const ColInt *>(relationData()) : nullptr;
  }
  const ColFloat *relationData_as_ColFloat() const {
    return relationData_type() == Relation_ColFloat ? static_cast<const ColFloat *>(relationData()) : nullptr;
  }
  const ColString *relationData_as_ColString() const {
    return relationData_type() == Relation_ColString ? static_cast<const ColString *>(relationData()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyVector(schema()) &&
           VerifyField<uint8_t>(verifier, VT_RELATIONDATA_TYPE) &&
           VerifyOffset(verifier, VT_RELATIONDATA) &&
           VerifyRelation(verifier, relationData(), relationData_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Rows *Root::relationData_as<Rows>() const {
  return relationData_as_Rows();
}

template<> inline const Col *Root::relationData_as<Col>() const {
  return relationData_as_Col();
}

template<> inline const ColInt *Root::relationData_as<ColInt>() const {
  return relationData_as_ColInt();
}

template<> inline const ColFloat *Root::relationData_as<ColFloat>() const {
  return relationData_as_ColFloat();
}

template<> inline const ColString *Root::relationData_as<ColString>() const {
  return relationData_as_ColString();
}

struct RootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_schema(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> schema) {
    fbb_.AddOffset(Root::VT_SCHEMA, schema);
  }
  void add_relationData_type(Relation relationData_type) {
    fbb_.AddElement<uint8_t>(Root::VT_RELATIONDATA_TYPE, static_cast<uint8_t>(relationData_type), 0);
  }
  void add_relationData(flatbuffers::Offset<void> relationData) {
    fbb_.AddOffset(Root::VT_RELATIONDATA, relationData);
  }
  explicit RootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RootBuilder &operator=(const RootBuilder &);
  flatbuffers::Offset<Root> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Root>(end);
    return o;
  }
};

inline flatbuffers::Offset<Root> CreateRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> schema = 0,
    Relation relationData_type = Relation_NONE,
    flatbuffers::Offset<void> relationData = 0) {
  RootBuilder builder_(_fbb);
  builder_.add_relationData(relationData);
  builder_.add_schema(schema);
  builder_.add_relationData_type(relationData_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Root> CreateRootDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *schema = nullptr,
    Relation relationData_type = Relation_NONE,
    flatbuffers::Offset<void> relationData = 0) {
  auto schema__ = schema ? _fbb.CreateVector<uint8_t>(*schema) : 0;
  return Tables::CreateRoot(
      _fbb,
      schema__,
      relationData_type,
      relationData);
}

struct Rows FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKYHOOK_VERSION = 4,
    VT_SCHEMA_VERSION = 6,
    VT_TABLE_NAME = 8,
    VT_SCHEMA = 10,
    VT_NROWS = 12,
    VT_NCOLS = 14,
    VT_LAYOUT = 16,
    VT_RIDS = 18,
    VT_DATA = 20
  };
  uint8_t skyhook_version() const {
    return GetField<uint8_t>(VT_SKYHOOK_VERSION, 0);
  }
  uint8_t schema_version() const {
    return GetField<uint8_t>(VT_SCHEMA_VERSION, 0);
  }
  const flatbuffers::String *table_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TABLE_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *schema() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SCHEMA);
  }
  uint64_t nrows() const {
    return GetField<uint64_t>(VT_NROWS, 0);
  }
  uint64_t ncols() const {
    return GetField<uint64_t>(VT_NCOLS, 0);
  }
  const flatbuffers::String *layout() const {
    return GetPointer<const flatbuffers::String *>(VT_LAYOUT);
  }
  const flatbuffers::Vector<uint64_t> *RIDs() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_RIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Record>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Record>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SKYHOOK_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_SCHEMA_VERSION) &&
           VerifyOffset(verifier, VT_TABLE_NAME) &&
           verifier.VerifyString(table_name()) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyVector(schema()) &&
           verifier.VerifyVectorOfStrings(schema()) &&
           VerifyField<uint64_t>(verifier, VT_NROWS) &&
           VerifyField<uint64_t>(verifier, VT_NCOLS) &&
           VerifyOffset(verifier, VT_LAYOUT) &&
           verifier.VerifyString(layout()) &&
           VerifyOffset(verifier, VT_RIDS) &&
           verifier.VerifyVector(RIDs()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct RowsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skyhook_version(uint8_t skyhook_version) {
    fbb_.AddElement<uint8_t>(Rows::VT_SKYHOOK_VERSION, skyhook_version, 0);
  }
  void add_schema_version(uint8_t schema_version) {
    fbb_.AddElement<uint8_t>(Rows::VT_SCHEMA_VERSION, schema_version, 0);
  }
  void add_table_name(flatbuffers::Offset<flatbuffers::String> table_name) {
    fbb_.AddOffset(Rows::VT_TABLE_NAME, table_name);
  }
  void add_schema(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> schema) {
    fbb_.AddOffset(Rows::VT_SCHEMA, schema);
  }
  void add_nrows(uint64_t nrows) {
    fbb_.AddElement<uint64_t>(Rows::VT_NROWS, nrows, 0);
  }
  void add_ncols(uint64_t ncols) {
    fbb_.AddElement<uint64_t>(Rows::VT_NCOLS, ncols, 0);
  }
  void add_layout(flatbuffers::Offset<flatbuffers::String> layout) {
    fbb_.AddOffset(Rows::VT_LAYOUT, layout);
  }
  void add_RIDs(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> RIDs) {
    fbb_.AddOffset(Rows::VT_RIDS, RIDs);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Record>>> data) {
    fbb_.AddOffset(Rows::VT_DATA, data);
  }
  explicit RowsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RowsBuilder &operator=(const RowsBuilder &);
  flatbuffers::Offset<Rows> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rows>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rows> CreateRows(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t skyhook_version = 0,
    uint8_t schema_version = 0,
    flatbuffers::Offset<flatbuffers::String> table_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> schema = 0,
    uint64_t nrows = 0,
    uint64_t ncols = 0,
    flatbuffers::Offset<flatbuffers::String> layout = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> RIDs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Record>>> data = 0) {
  RowsBuilder builder_(_fbb);
  builder_.add_ncols(ncols);
  builder_.add_nrows(nrows);
  builder_.add_data(data);
  builder_.add_RIDs(RIDs);
  builder_.add_layout(layout);
  builder_.add_schema(schema);
  builder_.add_table_name(table_name);
  builder_.add_schema_version(schema_version);
  builder_.add_skyhook_version(skyhook_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Rows> CreateRowsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t skyhook_version = 0,
    uint8_t schema_version = 0,
    const char *table_name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *schema = nullptr,
    uint64_t nrows = 0,
    uint64_t ncols = 0,
    const char *layout = nullptr,
    const std::vector<uint64_t> *RIDs = nullptr,
    const std::vector<flatbuffers::Offset<Record>> *data = nullptr) {
  auto table_name__ = table_name ? _fbb.CreateString(table_name) : 0;
  auto schema__ = schema ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*schema) : 0;
  auto layout__ = layout ? _fbb.CreateString(layout) : 0;
  auto RIDs__ = RIDs ? _fbb.CreateVector<uint64_t>(*RIDs) : 0;
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<Record>>(*data) : 0;
  return Tables::CreateRows(
      _fbb,
      skyhook_version,
      schema_version,
      table_name__,
      schema__,
      nrows,
      ncols,
      layout__,
      RIDs__,
      data__);
}

struct Record FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  const flatbuffers::Vector<uint8_t> *data_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA_TYPE) &&
           verifier.VerifyVector(data_type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyDataVector(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct RecordBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type) {
    fbb_.AddOffset(Record::VT_DATA_TYPE, data_type);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data) {
    fbb_.AddOffset(Record::VT_DATA, data);
  }
  explicit RecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecordBuilder &operator=(const RecordBuilder &);
  flatbuffers::Offset<Record> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Record>(end);
    return o;
  }
};

inline flatbuffers::Offset<Record> CreateRecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data = 0) {
  RecordBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Record> CreateRecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *data = nullptr) {
  auto data_type__ = data_type ? _fbb.CreateVector<uint8_t>(*data_type) : 0;
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<void>>(*data) : 0;
  return Tables::CreateRecord(
      _fbb,
      data_type__,
      data__);
}

struct Col FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKYHOOK_VERSION = 4,
    VT_SCHEMA_VERSION = 6,
    VT_COL_NAME = 8,
    VT_COL_INDEX = 10,
    VT_NROWS = 12,
    VT_RIDS = 14,
    VT_DATA_TYPE = 16,
    VT_DATA = 18
  };
  uint8_t skyhook_version() const {
    return GetField<uint8_t>(VT_SKYHOOK_VERSION, 0);
  }
  uint8_t schema_version() const {
    return GetField<uint8_t>(VT_SCHEMA_VERSION, 0);
  }
  const flatbuffers::String *col_name() const {
    return GetPointer<const flatbuffers::String *>(VT_COL_NAME);
  }
  uint8_t col_index() const {
    return GetField<uint8_t>(VT_COL_INDEX, 0);
  }
  uint8_t nrows() const {
    return GetField<uint8_t>(VT_NROWS, 0);
  }
  const flatbuffers::Vector<uint64_t> *RIDs() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_RIDS);
  }
  Data data_type() const {
    return static_cast<Data>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const IntData *data_as_IntData() const {
    return data_type() == Data_IntData ? static_cast<const IntData *>(data()) : nullptr;
  }
  const FloatData *data_as_FloatData() const {
    return data_type() == Data_FloatData ? static_cast<const FloatData *>(data()) : nullptr;
  }
  const StringData *data_as_StringData() const {
    return data_type() == Data_StringData ? static_cast<const StringData *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SKYHOOK_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_SCHEMA_VERSION) &&
           VerifyOffset(verifier, VT_COL_NAME) &&
           verifier.VerifyString(col_name()) &&
           VerifyField<uint8_t>(verifier, VT_COL_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_NROWS) &&
           VerifyOffset(verifier, VT_RIDS) &&
           verifier.VerifyVector(RIDs()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const IntData *Col::data_as<IntData>() const {
  return data_as_IntData();
}

template<> inline const FloatData *Col::data_as<FloatData>() const {
  return data_as_FloatData();
}

template<> inline const StringData *Col::data_as<StringData>() const {
  return data_as_StringData();
}

struct ColBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skyhook_version(uint8_t skyhook_version) {
    fbb_.AddElement<uint8_t>(Col::VT_SKYHOOK_VERSION, skyhook_version, 0);
  }
  void add_schema_version(uint8_t schema_version) {
    fbb_.AddElement<uint8_t>(Col::VT_SCHEMA_VERSION, schema_version, 0);
  }
  void add_col_name(flatbuffers::Offset<flatbuffers::String> col_name) {
    fbb_.AddOffset(Col::VT_COL_NAME, col_name);
  }
  void add_col_index(uint8_t col_index) {
    fbb_.AddElement<uint8_t>(Col::VT_COL_INDEX, col_index, 0);
  }
  void add_nrows(uint8_t nrows) {
    fbb_.AddElement<uint8_t>(Col::VT_NROWS, nrows, 0);
  }
  void add_RIDs(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> RIDs) {
    fbb_.AddOffset(Col::VT_RIDS, RIDs);
  }
  void add_data_type(Data data_type) {
    fbb_.AddElement<uint8_t>(Col::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Col::VT_DATA, data);
  }
  explicit ColBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColBuilder &operator=(const ColBuilder &);
  flatbuffers::Offset<Col> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Col>(end);
    return o;
  }
};

inline flatbuffers::Offset<Col> CreateCol(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t skyhook_version = 0,
    uint8_t schema_version = 0,
    flatbuffers::Offset<flatbuffers::String> col_name = 0,
    uint8_t col_index = 0,
    uint8_t nrows = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> RIDs = 0,
    Data data_type = Data_NONE,
    flatbuffers::Offset<void> data = 0) {
  ColBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_RIDs(RIDs);
  builder_.add_col_name(col_name);
  builder_.add_data_type(data_type);
  builder_.add_nrows(nrows);
  builder_.add_col_index(col_index);
  builder_.add_schema_version(schema_version);
  builder_.add_skyhook_version(skyhook_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Col> CreateColDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t skyhook_version = 0,
    uint8_t schema_version = 0,
    const char *col_name = nullptr,
    uint8_t col_index = 0,
    uint8_t nrows = 0,
    const std::vector<uint64_t> *RIDs = nullptr,
    Data data_type = Data_NONE,
    flatbuffers::Offset<void> data = 0) {
  auto col_name__ = col_name ? _fbb.CreateString(col_name) : 0;
  auto RIDs__ = RIDs ? _fbb.CreateVector<uint64_t>(*RIDs) : 0;
  return Tables::CreateCol(
      _fbb,
      skyhook_version,
      schema_version,
      col_name__,
      col_index,
      nrows,
      RIDs__,
      data_type,
      data);
}

struct IntData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint64_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct IntDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> data) {
    fbb_.AddOffset(IntData::VT_DATA, data);
  }
  explicit IntDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntDataBuilder &operator=(const IntDataBuilder &);
  flatbuffers::Offset<IntData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntData>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntData> CreateIntData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> data = 0) {
  IntDataBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntData> CreateIntDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint64_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint64_t>(*data) : 0;
  return Tables::CreateIntData(
      _fbb,
      data__);
}

struct FloatData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct FloatDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(FloatData::VT_DATA, data);
  }
  explicit FloatDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloatDataBuilder &operator=(const FloatDataBuilder &);
  flatbuffers::Offset<FloatData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatData> CreateFloatData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  FloatDataBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<FloatData> CreateFloatDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return Tables::CreateFloatData(
      _fbb,
      data__);
}

struct StringData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfStrings(data()) &&
           verifier.EndTable();
  }
};

struct StringDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> data) {
    fbb_.AddOffset(StringData::VT_DATA, data);
  }
  explicit StringDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringDataBuilder &operator=(const StringDataBuilder &);
  flatbuffers::Offset<StringData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringData>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringData> CreateStringData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> data = 0) {
  StringDataBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringData> CreateStringDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*data) : 0;
  return Tables::CreateStringData(
      _fbb,
      data__);
}

struct ColInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKYHOOK_VERSION = 4,
    VT_SCHEMA_VERSION = 6,
    VT_COL_NAME = 8,
    VT_COL_INDEX = 10,
    VT_NROWS = 12,
    VT_RIDS = 14,
    VT_DATA = 16
  };
  uint8_t skyhook_version() const {
    return GetField<uint8_t>(VT_SKYHOOK_VERSION, 0);
  }
  uint8_t schema_version() const {
    return GetField<uint8_t>(VT_SCHEMA_VERSION, 0);
  }
  const flatbuffers::String *col_name() const {
    return GetPointer<const flatbuffers::String *>(VT_COL_NAME);
  }
  uint8_t col_index() const {
    return GetField<uint8_t>(VT_COL_INDEX, 0);
  }
  uint8_t nrows() const {
    return GetField<uint8_t>(VT_NROWS, 0);
  }
  const flatbuffers::Vector<uint64_t> *RIDs() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_RIDS);
  }
  const flatbuffers::Vector<uint64_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SKYHOOK_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_SCHEMA_VERSION) &&
           VerifyOffset(verifier, VT_COL_NAME) &&
           verifier.VerifyString(col_name()) &&
           VerifyField<uint8_t>(verifier, VT_COL_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_NROWS) &&
           VerifyOffset(verifier, VT_RIDS) &&
           verifier.VerifyVector(RIDs()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ColIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skyhook_version(uint8_t skyhook_version) {
    fbb_.AddElement<uint8_t>(ColInt::VT_SKYHOOK_VERSION, skyhook_version, 0);
  }
  void add_schema_version(uint8_t schema_version) {
    fbb_.AddElement<uint8_t>(ColInt::VT_SCHEMA_VERSION, schema_version, 0);
  }
  void add_col_name(flatbuffers::Offset<flatbuffers::String> col_name) {
    fbb_.AddOffset(ColInt::VT_COL_NAME, col_name);
  }
  void add_col_index(uint8_t col_index) {
    fbb_.AddElement<uint8_t>(ColInt::VT_COL_INDEX, col_index, 0);
  }
  void add_nrows(uint8_t nrows) {
    fbb_.AddElement<uint8_t>(ColInt::VT_NROWS, nrows, 0);
  }
  void add_RIDs(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> RIDs) {
    fbb_.AddOffset(ColInt::VT_RIDS, RIDs);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> data) {
    fbb_.AddOffset(ColInt::VT_DATA, data);
  }
  explicit ColIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColIntBuilder &operator=(const ColIntBuilder &);
  flatbuffers::Offset<ColInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColInt> CreateColInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t skyhook_version = 0,
    uint8_t schema_version = 0,
    flatbuffers::Offset<flatbuffers::String> col_name = 0,
    uint8_t col_index = 0,
    uint8_t nrows = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> RIDs = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> data = 0) {
  ColIntBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_RIDs(RIDs);
  builder_.add_col_name(col_name);
  builder_.add_nrows(nrows);
  builder_.add_col_index(col_index);
  builder_.add_schema_version(schema_version);
  builder_.add_skyhook_version(skyhook_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<ColInt> CreateColIntDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t skyhook_version = 0,
    uint8_t schema_version = 0,
    const char *col_name = nullptr,
    uint8_t col_index = 0,
    uint8_t nrows = 0,
    const std::vector<uint64_t> *RIDs = nullptr,
    const std::vector<uint64_t> *data = nullptr) {
  auto col_name__ = col_name ? _fbb.CreateString(col_name) : 0;
  auto RIDs__ = RIDs ? _fbb.CreateVector<uint64_t>(*RIDs) : 0;
  auto data__ = data ? _fbb.CreateVector<uint64_t>(*data) : 0;
  return Tables::CreateColInt(
      _fbb,
      skyhook_version,
      schema_version,
      col_name__,
      col_index,
      nrows,
      RIDs__,
      data__);
}

struct ColFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKYHOOK_VERSION = 4,
    VT_SCHEMA_VERSION = 6,
    VT_COL_NAME = 8,
    VT_COL_INDEX = 10,
    VT_NROWS = 12,
    VT_RIDS = 14,
    VT_DATA = 16
  };
  uint8_t skyhook_version() const {
    return GetField<uint8_t>(VT_SKYHOOK_VERSION, 0);
  }
  uint8_t schema_version() const {
    return GetField<uint8_t>(VT_SCHEMA_VERSION, 0);
  }
  const flatbuffers::String *col_name() const {
    return GetPointer<const flatbuffers::String *>(VT_COL_NAME);
  }
  uint8_t col_index() const {
    return GetField<uint8_t>(VT_COL_INDEX, 0);
  }
  uint8_t nrows() const {
    return GetField<uint8_t>(VT_NROWS, 0);
  }
  const flatbuffers::Vector<uint64_t> *RIDs() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_RIDS);
  }
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SKYHOOK_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_SCHEMA_VERSION) &&
           VerifyOffset(verifier, VT_COL_NAME) &&
           verifier.VerifyString(col_name()) &&
           VerifyField<uint8_t>(verifier, VT_COL_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_NROWS) &&
           VerifyOffset(verifier, VT_RIDS) &&
           verifier.VerifyVector(RIDs()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ColFloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skyhook_version(uint8_t skyhook_version) {
    fbb_.AddElement<uint8_t>(ColFloat::VT_SKYHOOK_VERSION, skyhook_version, 0);
  }
  void add_schema_version(uint8_t schema_version) {
    fbb_.AddElement<uint8_t>(ColFloat::VT_SCHEMA_VERSION, schema_version, 0);
  }
  void add_col_name(flatbuffers::Offset<flatbuffers::String> col_name) {
    fbb_.AddOffset(ColFloat::VT_COL_NAME, col_name);
  }
  void add_col_index(uint8_t col_index) {
    fbb_.AddElement<uint8_t>(ColFloat::VT_COL_INDEX, col_index, 0);
  }
  void add_nrows(uint8_t nrows) {
    fbb_.AddElement<uint8_t>(ColFloat::VT_NROWS, nrows, 0);
  }
  void add_RIDs(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> RIDs) {
    fbb_.AddOffset(ColFloat::VT_RIDS, RIDs);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(ColFloat::VT_DATA, data);
  }
  explicit ColFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColFloatBuilder &operator=(const ColFloatBuilder &);
  flatbuffers::Offset<ColFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColFloat> CreateColFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t skyhook_version = 0,
    uint8_t schema_version = 0,
    flatbuffers::Offset<flatbuffers::String> col_name = 0,
    uint8_t col_index = 0,
    uint8_t nrows = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> RIDs = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  ColFloatBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_RIDs(RIDs);
  builder_.add_col_name(col_name);
  builder_.add_nrows(nrows);
  builder_.add_col_index(col_index);
  builder_.add_schema_version(schema_version);
  builder_.add_skyhook_version(skyhook_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<ColFloat> CreateColFloatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t skyhook_version = 0,
    uint8_t schema_version = 0,
    const char *col_name = nullptr,
    uint8_t col_index = 0,
    uint8_t nrows = 0,
    const std::vector<uint64_t> *RIDs = nullptr,
    const std::vector<float> *data = nullptr) {
  auto col_name__ = col_name ? _fbb.CreateString(col_name) : 0;
  auto RIDs__ = RIDs ? _fbb.CreateVector<uint64_t>(*RIDs) : 0;
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return Tables::CreateColFloat(
      _fbb,
      skyhook_version,
      schema_version,
      col_name__,
      col_index,
      nrows,
      RIDs__,
      data__);
}

struct ColString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SKYHOOK_VERSION = 4,
    VT_SCHEMA_VERSION = 6,
    VT_COL_NAME = 8,
    VT_COL_INDEX = 10,
    VT_NROWS = 12,
    VT_RIDS = 14,
    VT_DATA = 16
  };
  uint8_t skyhook_version() const {
    return GetField<uint8_t>(VT_SKYHOOK_VERSION, 0);
  }
  uint8_t schema_version() const {
    return GetField<uint8_t>(VT_SCHEMA_VERSION, 0);
  }
  const flatbuffers::String *col_name() const {
    return GetPointer<const flatbuffers::String *>(VT_COL_NAME);
  }
  uint8_t col_index() const {
    return GetField<uint8_t>(VT_COL_INDEX, 0);
  }
  uint8_t nrows() const {
    return GetField<uint8_t>(VT_NROWS, 0);
  }
  const flatbuffers::Vector<uint64_t> *RIDs() const {
    return GetPointer<const flatbuffers::Vector<uint64_t> *>(VT_RIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SKYHOOK_VERSION) &&
           VerifyField<uint8_t>(verifier, VT_SCHEMA_VERSION) &&
           VerifyOffset(verifier, VT_COL_NAME) &&
           verifier.VerifyString(col_name()) &&
           VerifyField<uint8_t>(verifier, VT_COL_INDEX) &&
           VerifyField<uint8_t>(verifier, VT_NROWS) &&
           VerifyOffset(verifier, VT_RIDS) &&
           verifier.VerifyVector(RIDs()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfStrings(data()) &&
           verifier.EndTable();
  }
};

struct ColStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_skyhook_version(uint8_t skyhook_version) {
    fbb_.AddElement<uint8_t>(ColString::VT_SKYHOOK_VERSION, skyhook_version, 0);
  }
  void add_schema_version(uint8_t schema_version) {
    fbb_.AddElement<uint8_t>(ColString::VT_SCHEMA_VERSION, schema_version, 0);
  }
  void add_col_name(flatbuffers::Offset<flatbuffers::String> col_name) {
    fbb_.AddOffset(ColString::VT_COL_NAME, col_name);
  }
  void add_col_index(uint8_t col_index) {
    fbb_.AddElement<uint8_t>(ColString::VT_COL_INDEX, col_index, 0);
  }
  void add_nrows(uint8_t nrows) {
    fbb_.AddElement<uint8_t>(ColString::VT_NROWS, nrows, 0);
  }
  void add_RIDs(flatbuffers::Offset<flatbuffers::Vector<uint64_t>> RIDs) {
    fbb_.AddOffset(ColString::VT_RIDS, RIDs);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> data) {
    fbb_.AddOffset(ColString::VT_DATA, data);
  }
  explicit ColStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColStringBuilder &operator=(const ColStringBuilder &);
  flatbuffers::Offset<ColString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColString>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColString> CreateColString(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t skyhook_version = 0,
    uint8_t schema_version = 0,
    flatbuffers::Offset<flatbuffers::String> col_name = 0,
    uint8_t col_index = 0,
    uint8_t nrows = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint64_t>> RIDs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> data = 0) {
  ColStringBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_RIDs(RIDs);
  builder_.add_col_name(col_name);
  builder_.add_nrows(nrows);
  builder_.add_col_index(col_index);
  builder_.add_schema_version(schema_version);
  builder_.add_skyhook_version(skyhook_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<ColString> CreateColStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t skyhook_version = 0,
    uint8_t schema_version = 0,
    const char *col_name = nullptr,
    uint8_t col_index = 0,
    uint8_t nrows = 0,
    const std::vector<uint64_t> *RIDs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *data = nullptr) {
  auto col_name__ = col_name ? _fbb.CreateString(col_name) : 0;
  auto RIDs__ = RIDs ? _fbb.CreateVector<uint64_t>(*RIDs) : 0;
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*data) : 0;
  return Tables::CreateColString(
      _fbb,
      skyhook_version,
      schema_version,
      col_name__,
      col_index,
      nrows,
      RIDs__,
      data__);
}

inline bool VerifyRelation(flatbuffers::Verifier &verifier, const void *obj, Relation type) {
  switch (type) {
    case Relation_NONE: {
      return true;
    }
    case Relation_Rows: {
      auto ptr = reinterpret_cast<const Rows *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Relation_Col: {
      auto ptr = reinterpret_cast<const Col *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Relation_ColInt: {
      auto ptr = reinterpret_cast<const ColInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Relation_ColFloat: {
      auto ptr = reinterpret_cast<const ColFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Relation_ColString: {
      auto ptr = reinterpret_cast<const ColString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyRelationVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRelation(
        verifier,  values->Get(i), types->GetEnum<Relation>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type) {
  switch (type) {
    case Data_NONE: {
      return true;
    }
    case Data_IntData: {
      auto ptr = reinterpret_cast<const IntData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_FloatData: {
      auto ptr = reinterpret_cast<const FloatData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_StringData: {
      auto ptr = reinterpret_cast<const StringData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyData(
        verifier,  values->Get(i), types->GetEnum<Data>(i))) {
      return false;
    }
  }
  return true;
}

inline const Tables::Root *GetRoot(const void *buf) {
  return flatbuffers::GetRoot<Tables::Root>(buf);
}

inline const Tables::Root *GetSizePrefixedRoot(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Tables::Root>(buf);
}

inline bool VerifyRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Tables::Root>(nullptr);
}

inline bool VerifySizePrefixedRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Tables::Root>(nullptr);
}

inline void FinishRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Tables::Root> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Tables::Root> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Tables

#endif  // FLATBUFFERS_GENERATED_SKYROOT_TABLES_H_
